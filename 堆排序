/**
  2  * 堆排序：C++
  3  *
  4  * @author skywang
  5  * @date 2014/03/11
  6  */
  7 
  8 #include <iostream>
  9 using namespace std;
 10 
 11 /* 
 12  * (最大)堆的向下调整算法
 13  *
 14  * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 15  *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 16  *
 17  * 参数说明：
 18  *     a -- 待排序的数组
 19  *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 20  *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 21  */
 22 void maxHeapDown(int* a, int start, int end)
 23 {
 24     int c = start;            // 当前(current)节点的位置
 25     int l = 2*c + 1;        // 左(left)孩子的位置
 26     int tmp = a[c];            // 当前(current)节点的大小
 27     for (; l <= end; c=l,l=2*l+1)
 28     {
 29         // "l"是左孩子，"l+1"是右孩子
 30         if ( l < end && a[l] < a[l+1])
 31             l++;        // 左右两孩子中选择较大者，即m_heap[l+1]
 32         if (tmp >= a[l])
 33             break;        // 调整结束
 34         else            // 交换值
 35         {
 36             a[c] = a[l];
 37             a[l]= tmp;
 38         }
 39     }
 40 }
 41 
 42 /*
 43  * 堆排序(从小到大)
 44  *
 45  * 参数说明：
 46  *     a -- 待排序的数组
 47  *     n -- 数组的长度
 48  */
 49 void heapSortAsc(int* a, int n)
 50 {
 51     int i,tmp;
 52 
 53     // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
 54     for (i = n / 2 - 1; i >= 0; i--)
 55         maxHeapDown(a, i, n-1);
 56 
 57     // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
 58     for (i = n - 1; i > 0; i--)
 59     {
 60         // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
 61         tmp = a[0];
 62         a[0] = a[i];
 63         a[i] = tmp;
 64         // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
 65         // 即，保证a[i-1]是a[0...i-1]中的最大值。
 66         maxHeapDown(a, 0, i-1);
 67     }
 68 }
 69 
 70 /* 
 71  * (最小)堆的向下调整算法
 72  *
 73  * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
 74  *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
 75  *
 76  * 参数说明：
 77  *     a -- 待排序的数组
 78  *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
 79  *     end   -- 截至范围(一般为数组中最后一个元素的索引)
 80  */
 81 void minHeapDown(int* a, int start, int end)
 82 {
 83     int c = start;            // 当前(current)节点的位置
 84     int l = 2*c + 1;        // 左(left)孩子的位置
 85     int tmp = a[c];            // 当前(current)节点的大小
 86     for (; l <= end; c=l,l=2*l+1)
 87     {
 88         // "l"是左孩子，"l+1"是右孩子
 89         if ( l < end && a[l] > a[l+1])
 90             l++;        // 左右两孩子中选择较小者
 91         if (tmp <= a[l])
 92             break;        // 调整结束
 93         else            // 交换值
 94         {
 95             a[c] = a[l];
 96             a[l]= tmp;
 97         }
 98     }
 99 }
100 
101 /*
102  * 堆排序(从大到小)
103  *
104  * 参数说明：
105  *     a -- 待排序的数组
106  *     n -- 数组的长度
107  */
108 void heapSortDesc(int* a, int n)
109 {
110     int i,tmp;
111 
112     // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。
113     for (i = n / 2 - 1; i >= 0; i--)
114         minHeapDown(a, i, n-1);
115 
116     // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
117     for (i = n - 1; i > 0; i--)
118     {
119         // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
120         tmp = a[0];
121         a[0] = a[i];
122         a[i] = tmp;
123         // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
124         // 即，保证a[i-1]是a[0...i-1]中的最小值。
125         minHeapDown(a, 0, i-1);
126     }
127 }
128 
129 int main()
130 {
131     int i;
132     int a[] = {20,30,90,40,70,110,60,10,100,50,80};
133     int ilen = (sizeof(a)) / (sizeof(a[0]));
134 
135     cout << "before sort:";
136     for (i=0; i<ilen; i++)
137         cout << a[i] << " ";
138     cout << endl;
139 
140     heapSortAsc(a, ilen);            // 升序排列
141     //heapSortDesc(a, ilen);        // 降序排列
142 
143     cout << "after  sort:";
144     for (i=0; i<ilen; i++)
145         cout << a[i] << " ";
146     cout << endl;
147 
148     return 0;
149 }
